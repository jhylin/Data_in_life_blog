{
  "hash": "a8224f46fb560f23fac7b24c88e6b8fa",
  "result": {
    "markdown": "---\ntitle: Building a simple deep learning model about adverse drug reactions\ndate: 2025-1-8\nauthor: Jennifer HY Lin\ndraft: false\ncategories:\n  - Deep learning\n  - Pytorch\n  - RDKit\n  - Pandas\n  - Python\n  - ChEMBL database\n  - Toxicology\n  - Metabolism\n  - Cheminformatics\n---\n\n*The notebook from [this repository](https://github.com/jhylin/Adverse_drug_reactions) uses a venv created by [using uv](https://docs.astral.sh/uv/pip/environments/#creating-a-virtual-environment) with [a kernel set up this way](https://docs.astral.sh/uv/guides/integration/jupyter/#using-jupyter-from-vs-code).*\n\n*Some of the code blocks have been folded to keep the post length a bit more manageable - click on the code links to see full code (only applies to the HTML version, not the Jupyter notebook version).*\n\n<br>\n\n##### **Import libraries**\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn.functional import one_hot\nfrom torch.utils.data import TensorDataset, DataLoader\nimport numpy as np\nimport datamol as dm\nimport rdkit\nfrom rdkit import Chem\nfrom rdkit.Chem import rdFingerprintGenerator\nimport useful_rdkit_utils as uru\nimport sys\nfrom matplotlib import pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\nprint(f\"Pandas version used: {pd.__version__}\")\nprint(f\"PyTorch version used: {torch.__version__}\")\nprint(f\"NumPy version used: {np.__version__}\")\nprint(f\"RDKit version used: {rdkit.__version__}\")\nprint(f\"Python version used: {sys.version}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPandas version used: 2.2.3\nPyTorch version used: 2.2.2\nNumPy version used: 1.26.4\nRDKit version used: 2024.09.4\nPython version used: 3.12.7 (main, Oct 16 2024, 09:10:10) [Clang 18.1.8 ]\n```\n:::\n:::\n\n\n<br>\n\n##### **Import adverse drug reactions (ADRs) data**\n\nThis is an extremely small set of data compiled manually (by me) via references stated in the dataframe. For details about what and how the data are collected, I've prepared a separate post as a [data note](https://jhylin.github.io/Data_in_life_blog/posts/22_Simple_dnn_adrs/1_ADR_data.html) to explain key things about the data. It may not lead to a very significant result but it is done as an example of what an early or basic deep neural network (DNN) model may look like. Ideally there should be more training data and also more features added or used. I've hypothetically set the goal of this introductory piece to predict therapeutic drug classes from ADRs, molecular fingerprints and cytochrome P450 substrate strengths, but this won't be achieved in this initial post (yet).\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndata = pd.read_csv(\"cyp3a4_substrates.csv\")\nprint(data.shape)\ndata.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(27, 8)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=142}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>generic_drug_name</th>\n      <th>notes</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>first_ref</th>\n      <th>second_ref</th>\n      <th>date_checked</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>carbamazepine</td>\n      <td>NaN</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n      <td>drugs.com</td>\n      <td>nzf</td>\n      <td>211024</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>eliglustat</td>\n      <td>NaN</td>\n      <td>strong</td>\n      <td>metabolic_agents</td>\n      <td>diarrhea^^, oropharyngeal_pain^^, arthralgia^^...</td>\n      <td>drugs.com</td>\n      <td>emc</td>\n      <td>151124</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>flibanserin</td>\n      <td>NaN</td>\n      <td>strong</td>\n      <td>CNS_agents</td>\n      <td>dizziness^^, somnolence^^, sedation^, fatigue^...</td>\n      <td>drugs.com</td>\n      <td>Drugs@FDA</td>\n      <td>161124</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFor drug with astericks marked in \"notes\" column, see data notes under \"Exceptions or notes for ADRs\" section in [separate post](https://jhylin.github.io/Data_in_life_blog/posts/22_Simple_dnn_adrs/1_ADR_data.html).\n\nI'm dropping some of the columns that are not going to be used later.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\ndf = data.drop([\n    \"notes\",\n    \"first_ref\", \n    \"second_ref\", \n    \"date_checked\"\n    ], axis=1)\ndf.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=143}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>generic_drug_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>carbamazepine</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>eliglustat</td>\n      <td>strong</td>\n      <td>metabolic_agents</td>\n      <td>diarrhea^^, oropharyngeal_pain^^, arthralgia^^...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>flibanserin</td>\n      <td>strong</td>\n      <td>CNS_agents</td>\n      <td>dizziness^^, somnolence^^, sedation^, fatigue^...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Import SMILES data from ChEMBL**\n\nBefore extracting data from ChEMBL, I'm getting a list of drug names in capital letters ready first which can be fed into chembl_downloader with my old cyp_drugs.py to retrieve the SMILES of these drugs.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nstring = df[\"generic_drug_name\"].tolist()\n# Convert list of drugs into multiple strings of drug names\ndrugs = f\"'{\"','\".join(string)}'\"\n# Convert from lower case to upper case\nfor letter in drugs:\n    if letter.islower():\n        drugs = drugs.replace(letter, letter.upper())\nprint(drugs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'CARBAMAZEPINE','ELIGLUSTAT','FLIBANSERIN','IMATINIB','IBRUTINIB','NERATINIB','ESOMEPRAZOLE','OMEPRAZOLE','IVACAFTOR','NALOXEGOL','OXYCODONE','SIROLIMUS','TERFENADINE','DIAZEPAM','HYDROCORTISONE','LANSOPRAZOLE','PANTOPRAZOLE','LERCANIDIPINE','NALDEMEDINE','NELFINAVIR','TELAPREVIR','ONDANSETRON','QUININE','RIBOCICLIB','SUVOREXANT','TELITHROMYCIN','TEMSIROLIMUS'\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\n# Get SMILES for each drug (via copying-and-pasting the previous cell output - attempted various ways to feed the string\n# directly into cyp_drugs.py, current way seems to be the most straightforward one...)\nfrom cyp_drugs import chembl_drugs\n# Using ChEMBL version 34\ndf_3a4 = chembl_drugs(\n    'CARBAMAZEPINE','ELIGLUSTAT','FLIBANSERIN','IMATINIB','IBRUTINIB','NERATINIB','ESOMEPRAZOLE','OMEPRAZOLE','IVACAFTOR','NALOXEGOL','OXYCODONE','SIROLIMUS','TERFENADINE','DIAZEPAM','HYDROCORTISONE','LANSOPRAZOLE','PANTOPRAZOLE','LERCANIDIPINE','NALDEMEDINE','NELFINAVIR','TELAPREVIR','ONDANSETRON','QUININE','RIBOCICLIB','SUVOREXANT','TELITHROMYCIN','TEMSIROLIMUS', \n    #file_name=\"All_cyp3a4_smiles\"\n    )\nprint(df_3a4.shape)\ndf_3a4.head(3)\n\n## Note: latest ChEMBL version 35 (as from 1st Dec 2024) seems to be taking a long time to load (no output after ~7min), \n## both versions 33 & 34 are ok with outputs loading within a few secs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(27, 4)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=145}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>chembl_id</th>\n      <th>pref_name</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL108</td>\n      <td>CARBAMAZEPINE</td>\n      <td>4</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL12</td>\n      <td>DIAZEPAM</td>\n      <td>4</td>\n      <td>CN1C(=O)CN=C(c2ccccc2)c2cc(Cl)ccc21</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL2110588</td>\n      <td>ELIGLUSTAT</td>\n      <td>4</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Merge dataframes**\n\nNext, I'm renaming the drug name column and merging the two dataframes together where one contains the ADRs and the other one contains the SMILES. I'm also making sure all drug names are in upper case for both dataframes so they can merge properly.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\n# Rename column & change lower to uppercase\ndf = df.rename(columns={\"generic_drug_name\": \"pref_name\"})\ndf[\"pref_name\"] = df[\"pref_name\"].str.upper()\n# Merge df & df_3a4 \ndf = df.merge(df_3a4, how=\"left\", on=\"pref_name\")\ndf.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=146}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>pref_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>chembl_id</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CARBAMAZEPINE</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n      <td>CHEMBL108</td>\n      <td>4</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ELIGLUSTAT</td>\n      <td>strong</td>\n      <td>metabolic_agents</td>\n      <td>diarrhea^^, oropharyngeal_pain^^, arthralgia^^...</td>\n      <td>CHEMBL2110588</td>\n      <td>4</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>FLIBANSERIN</td>\n      <td>strong</td>\n      <td>CNS_agents</td>\n      <td>dizziness^^, somnolence^^, sedation^, fatigue^...</td>\n      <td>CHEMBL231068</td>\n      <td>4</td>\n      <td>O=c1[nH]c2ccccc2n1CCN1CCN(c2cccc(C(F)(F)F)c2)CC1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Parse SMILES**\n\nThen I'm parsing the canonical SMILES through my old script to generate these small molecules as RDKit molecules and standardised SMILES, making sure these SMILES are parsable.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\n# Using my previous code to preprocess small mols\n# disable rdkit messages\ndm.disable_rdkit_log()\n\n#  The following function code were adapted from datamol.io\ndef preprocess(row):\n\n    \"\"\"\n    Function to preprocess, fix, standardise, sanitise compounds \n    and then generate various molecular representations based on these molecules.\n    Can be utilised as df.apply(preprocess, axis=1).\n\n    :param smiles_column: SMILES column name (needs to be names as \"canonical_smiles\") \n    derived from ChEMBL database (or any other sources) via an input dataframe\n    :param mol: RDKit molecules\n    :return: preprocessed RDKit molecules, standardised SMILES, SELFIES, \n    InChI and InChI keys added as separate columns in the dataframe\n    \"\"\"\n\n    # smiles_column = strings object\n    smiles_column = \"canonical_smiles\"\n    # Convert each compound into a RDKit molecule in the smiles column\n    mol = dm.to_mol(row[smiles_column], ordered=True)\n    # Fix common errors in the molecules\n    mol = dm.fix_mol(mol)\n    # Sanitise the molecules \n    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)\n    # Standardise the molecules\n    mol = dm.standardize_mol(\n        mol,\n        # Switch on to disconnect metal ions\n        disconnect_metals=True,\n        normalize=True,\n        reionize=True,\n        # Switch on \"uncharge\" to neutralise charges\n        uncharge=True,\n        # Taking care of stereochemistries of compounds\n        # Note: this uses the older approach of \"AssignStereochemistry()\" from RDKit\n        # https://github.com/datamol-io/datamol/blob/main/datamol/mol.py#L488\n        stereo=True,\n    )\n\n    # Adding following rows of different molecular representations \n    row[\"rdkit_mol\"] = dm.to_mol(mol)\n    row[\"standard_smiles\"] = dm.standardize_smiles(str(dm.to_smiles(mol)))\n    #row[\"selfies\"] = dm.to_selfies(mol)\n    #row[\"inchi\"] = dm.to_inchi(mol)\n    #row[\"inchikey\"] = dm.to_inchikey(mol)\n    return row\n\ndf_p3a4 = df.apply(preprocess, axis = 1)\nprint(df_p3a4.shape)\ndf_p3a4.head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(27, 9)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=147}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>pref_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>chembl_id</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CARBAMAZEPINE</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n      <td>CHEMBL108</td>\n      <td>4</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472ca030&gt;</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ELIGLUSTAT</td>\n      <td>strong</td>\n      <td>metabolic_agents</td>\n      <td>diarrhea^^, oropharyngeal_pain^^, arthralgia^^...</td>\n      <td>CHEMBL2110588</td>\n      <td>4</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472c8040&gt;</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>FLIBANSERIN</td>\n      <td>strong</td>\n      <td>CNS_agents</td>\n      <td>dizziness^^, somnolence^^, sedation^, fatigue^...</td>\n      <td>CHEMBL231068</td>\n      <td>4</td>\n      <td>O=c1[nH]c2ccccc2n1CCN1CCN(c2cccc(C(F)(F)F)c2)CC1</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472cbca0&gt;</td>\n      <td>O=c1[nH]c2ccccc2n1CCN1CCN(c2cccc(C(F)(F)F)c2)CC1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Split data**\n\nRandom splits usually lead to overly optimistic models, where testing molecules are too similar to traininig molecules leading to many problems. This is further discussed in two other blog posts that I've found useful - [post by Greg Landrum](https://greglandrum.github.io/rdkit-blog/posts/2024-05-31-scaffold-splits-and-murcko-scaffolds1.html) and [post by Pat Walters](https://practicalcheminformatics.blogspot.com/2024/11/some-thoughts-on-splitting-chemical.html).\n\nHere I'm trying out Pat's [useful_rdkit_utils](https://github.com/PatWalters/useful_rdkit_utils)' GroupKFoldShuffle code (code originated from [this thread](https://github.com/scikit-learn/scikit-learn/issues/20520)) to split data (Butina clustering/splits). To do this, it requires SMILES to generate molecular fingerprints which will be used in the training and testing sets (potentially for future posts and in real-life cases, more things can be done with the SMILES or other molecular representations for machine learning, but to keep this post easy-to-read, I'll stick with only generating the Morgan fingerprints for now). \n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\n# Generate numpy arrays containing the fingerprints \ndf_p3a4['fp'] = df_p3a4.rdkit_mol.apply(rdFingerprintGenerator.GetMorganGenerator().GetCountFingerprintAsNumPy)\n\n# Get Butina cluster labels\ndf_p3a4[\"butina_cluster\"] = uru.get_butina_clusters(df_p3a4.standard_smiles)\n\n# Set up a GroupKFoldShuffle object\ngroup_kfold_shuffle = uru.GroupKFoldShuffle(n_splits=5, shuffle=True)\n\n# Using cross-validation/doing data split\n## X = np.stack(df_s3a4.fp), y = df.adverse_drug_reactions, group labels = df_s3a4.butina_cluster\nfor train, test in group_kfold_shuffle.split(np.stack(df_p3a4.fp), df.adverse_drug_reactions, df_p3a4.butina_cluster):\n    print(len(train),len(test))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n20 7\n23 4\n23 4\n23 4\n19 8\n```\n:::\n:::\n\n\n<br>\n\n##### **Locate training and testing sets after data split**\n\nWhile trying to figure out how to locate training and testing sets after the data split, I've gone into a mini rabbit hole myself (a self-confusing session but gladly it clears up when my thought process goes further...). For example, some of the ways I've planned to try: create a dictionary as {index: butina label} first - butina cluster labels vs. index e.g. df_s3a4[\"butina_cluster\"], or maybe can directly convert from NumPy array to tensor - will need to locate drugs via indices first to specify training and testing sets, e.g. torch_train = torch.from_numpy(train) or torch_test = torch.from_numpy(test). It is actually simpler than this, which is to use pd.DataFrame.iloc() as shown below.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Training set indices\ntrain\n```\n\n::: {.cell-output .cell-output-display execution_count=149}\n```\narray([ 0,  1,  3,  4,  5,  8,  9, 10, 12, 13, 14, 17, 18, 19, 20, 21, 23,\n       24, 25])\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# What df_p3a4 now looks like after data split - with \"fp\" and \"butina_cluster\" columns added\ndf_p3a4.head(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=150}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>pref_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>chembl_id</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n      <th>fp</th>\n      <th>butina_cluster</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CARBAMAZEPINE</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n      <td>CHEMBL108</td>\n      <td>4</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472ca030&gt;</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n      <td>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...</td>\n      <td>20</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Convert indices into list\ntrain_set = train.tolist()\n# Locate drugs and drug info via pd.DataFrame.iloc\ndf_train = df_p3a4.iloc[train_set]\nprint(df_train.shape)\ndf_train.head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(19, 11)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=151}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>pref_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>chembl_id</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n      <th>fp</th>\n      <th>butina_cluster</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CARBAMAZEPINE</td>\n      <td>strong</td>\n      <td>antiepileptics</td>\n      <td>constipation^^, leucopenia^^, dizziness^^, som...</td>\n      <td>CHEMBL108</td>\n      <td>4</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472ca030&gt;</td>\n      <td>NC(=O)N1c2ccccc2C=Cc2ccccc21</td>\n      <td>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...</td>\n      <td>20</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ELIGLUSTAT</td>\n      <td>strong</td>\n      <td>metabolic_agents</td>\n      <td>diarrhea^^, oropharyngeal_pain^^, arthralgia^^...</td>\n      <td>CHEMBL2110588</td>\n      <td>4</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472c8040&gt;</td>\n      <td>CCCCCCCC(=O)N[C@H](CN1CCCC1)[C@H](O)c1ccc2c(c1...</td>\n      <td>[0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...</td>\n      <td>19</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Testing set indices\ntest\n```\n\n::: {.cell-output .cell-output-display execution_count=152}\n```\narray([ 2,  6,  7, 11, 15, 16, 22, 26])\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ntest_set = test.tolist()\ndf_test = df_p3a4.iloc[test_set]\nprint(df_test.shape)\ndf_test.head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(8, 11)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=153}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>pref_name</th>\n      <th>cyp_strength_of_evidence</th>\n      <th>drug_class</th>\n      <th>adverse_drug_reactions</th>\n      <th>chembl_id</th>\n      <th>max_phase</th>\n      <th>canonical_smiles</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n      <th>fp</th>\n      <th>butina_cluster</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2</th>\n      <td>FLIBANSERIN</td>\n      <td>strong</td>\n      <td>CNS_agents</td>\n      <td>dizziness^^, somnolence^^, sedation^, fatigue^...</td>\n      <td>CHEMBL231068</td>\n      <td>4</td>\n      <td>O=c1[nH]c2ccccc2n1CCN1CCN(c2cccc(C(F)(F)F)c2)CC1</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x1472cbca0&gt;</td>\n      <td>O=c1[nH]c2ccccc2n1CCN1CCN(c2cccc(C(F)(F)F)c2)CC1</td>\n      <td>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...</td>\n      <td>18</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>ESOMEPRAZOLE</td>\n      <td>strong</td>\n      <td>proton_pump_inhibitors</td>\n      <td>headache^^, flatulence^^, dizziness^, somnolen...</td>\n      <td>CHEMBL1201320</td>\n      <td>4</td>\n      <td>COc1ccc2[nH]c([S@@+]([O-])Cc3ncc(C)c(OC)c3C)nc2c1</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x14733bd80&gt;</td>\n      <td>COc1ccc2[nH]c([S@@+]([O-])Cc3ncc(C)c(OC)c3C)nc2c1</td>\n      <td>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Set up training and testing sets for X and y variables**\n\nThis part involves converting X (features) and y (target) variables into either one-hot encodings or vector embeddings, since I'll be dealing with categories/words/ADRs and not numbers, and also to split each X and y variables into training and testing sets. At the very beginning, I've thought about using scikit_learn's train_test_split(), but then realised that I should not need to do this as it's already been done in the previous step (obviously I'm confusing myself again...). Essentially, this step can be integrated with the one-hot encoding and vector embeddings part as shown below.\n\nThere are three coding issues that have triggered warning messages when I'm trying to figure out how to convert CYP strengths into one-hot encodings:\n\n1. A useful [thread](https://github.com/pandas-dev/pandas/issues/57734) has helped me to solve the downcasting issue in pd.DataFrame.replace() when trying to do one-hot encoding to replace the CYP strengths for each drug\n\n2. A Pandas setting-with-copy warning shows if using df[\"column_name\"]:\n\n> A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead\n\nThe solution is to enable the copy-on-write globally (as commented in the code below; from [Pandas reference](https://pandas.pydata.org/pandas-docs/stable/user_guide/copy_on_write.html#copy-on-write-cow)).\n\n3. PyTorch user warning appers if using df_train[\"cyp_strength_of_evidence\"].values, as this leads to non-writable tensors with a warning like this:\n\n> UserWarning: The given NumPy array is not writable, and PyTorch does not support non-writable tensors. This means writing to this tensor will result in undefined behavior. You may want to copy the array to protect its data or make it writable before converting it to a tensor. This type of warning will be suppressed for the rest of this program. (Triggered internally at /Users/runner/work/pytorch/pytorch/pytorch/torch/csrc/utils/tensor_numpy.cpp:212.)\n\nOne of the solutions is to add copy() e.g. col_encoded = one_hot(torch.from_numpy(df[\"column_name\"].values.copy()) % total_numbers_in_column) or alternatively, convert column into numpy array first, then make the numpy array writeable (which is what I've used in the code below).\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\n## X_train\n# 1. Convert \"cyp_strength_of_evidence\" column into one-hot encoding\n# Enable copy-on-write globally to remove the warning\npd.options.mode.copy_on_write = True\n\n# Replace CYP strength as numbers\nwith pd.option_context('future.no_silent_downcasting', True):\n   df_train[\"cyp_strength_of_evidence\"] = df_train[\"cyp_strength_of_evidence\"].replace({\"strong\": 1, \"mod\": 2}).infer_objects()\n   df_test[\"cyp_strength_of_evidence\"] = df_test[\"cyp_strength_of_evidence\"].replace({\"strong\": 1, \"mod\": 2}).infer_objects()\n\n# Get total number of CYP strengths in df\ntotal_cyp_str_train = len(set(df_train[\"cyp_strength_of_evidence\"]))\n\n# Convert column into numpy array first, then make the numpy array writeable\ncyp_array_train = df_train[\"cyp_strength_of_evidence\"].to_numpy()\ncyp_array_train.flags.writeable = True\ncyp_str_train_t = one_hot(torch.from_numpy(cyp_array_train) % total_cyp_str_train)\ncyp_str_train_t\n```\n\n::: {.cell-output .cell-output-display execution_count=154}\n```\ntensor([[0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [0, 1],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0],\n        [1, 0]])\n```\n:::\n:::\n\n\nWithout going into too much details about vector embeddings (as there are a lot of useful learning materials about it online and in texts), here's roughly how I understand embeddings while working on this post. Embeddings are real-valued dense vectors that are normally in multi-dimensional arrays and they can represent and catch the context of a word or sentence, the semantic similarity and especially the relation of each word with other words in a corpus of texts. They roughly form the basis of natural language processing and also contribute to how large language models are built... in a very simplified sense, but obviously this can get complex if we want the models to do more. Here, I'm trying something experimental so I'm going to convert each ADR for each drug into embeddings.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code code-fold=\"true\"}\n# 2. Convert \"adverse_drug_reactions\" column into embeddings\n## see separate scripts used previously e.g. words_tensors.py \n## or Tensors_for_adrs_interactive.py to show step-by-step conversions from words to tensors\n\n# Save all ADRs from common ADRs column as a list (joining every row of ADRs in place only)\nadr_str_train = df_train[\"adverse_drug_reactions\"].tolist()\n# Join separate rows of strings into one complete string\nadr_string_train = \",\".join(adr_str_train)\n# Converting all ADRs into Torch tensors using words_tensors.py\nfrom words_tensors import words_tensors\nadr_train_t = words_tensors(adr_string_train)\nadr_train_t\n```\n\n::: {.cell-output .cell-output-display execution_count=155}\n```\ntensor([[ 0.2880, -1.1804],\n        [ 0.6725,  0.9416],\n        [-1.7143,  0.3996],\n        ...,\n        [ 0.3675, -0.1449],\n        [ 0.3549, -1.1478],\n        [-1.4670, -0.6858]], grad_fn=<EmbeddingBackward0>)\n```\n:::\n:::\n\n\nWhen trying to convert the \"fp\" column into tensors, there is one coding issue I've found relating to the data split step earlier. Each time the notebook is re-run with the kernel refreshed, the data split will lead to different proportions of training and testing sets due to the \"shuffle = True\", which subsequently leads to different training and testing set arrays. One of the ways to circumvent this is to turn off the shuffle but this is not ideal for model training. So an alternative way that I've tried is to use ndarray.size (which is the product of elements in ndarray.shape, equivalent to multiplying the numbers of rows and columns), and divide the row of the intended tensor shape by 2 as I'm trying to reshape training arrays so they're all in 2 columns in order for [torch.cat()](https://pytorch.org/docs/stable/generated/torch.cat.html#torch-cat) to work later.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"true\"}\n# 3. Convert \"fp\" column into tensors\n# Stack numpy arrays in fingerprint column\nfp_train_array = np.stack(df_train[\"fp\"])\n# Convert numpy array data type from uint32 to int32\nfp_train_array = fp_train_array.astype(\"int32\")\n# Create tensors from array\nfp_train_t = torch.from_numpy(fp_train_array)\n# Reshape tensors\nfp_train_t = torch.reshape(fp_train_t, (int(fp_train_array.size/2), 2))\nfp_train_t.shape # tensor.ndim to check tensor dimensions\n```\n\n::: {.cell-output .cell-output-display execution_count=156}\n```\ntorch.Size([19456, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nadr_train_t.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=157}\n```\ntorch.Size([517, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ncyp_str_train_t.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=158}\n```\ntorch.Size([19, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Concatenate adr tensors, fingerprint tensors and cyp strength tensors as X_train\nX_train = torch.cat([adr_train_t, fp_train_t, cyp_str_train_t], 0).float()\nX_train\n```\n\n::: {.cell-output .cell-output-display execution_count=159}\n```\ntensor([[ 0.2880, -1.1804],\n        [ 0.6725,  0.9416],\n        [-1.7143,  0.3996],\n        ...,\n        [ 1.0000,  0.0000],\n        [ 1.0000,  0.0000],\n        [ 1.0000,  0.0000]], grad_fn=<CatBackward0>)\n```\n:::\n:::\n\n\nX_test is being set up similarly as shown below.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code code-fold=\"true\"}\n## X_test\n# 1. Convert \"cyp_strength_of_evidence\" into one-hot encodings\ntotal_cyp_str_test = len(set(df_test[\"cyp_strength_of_evidence\"]))\narray_test = df_test[\"cyp_strength_of_evidence\"].to_numpy()\narray_test.flags.writeable = True\ncyp_str_test_t = one_hot(torch.from_numpy(array_test) % total_cyp_str_test)\n\n# 2. Convert \"adverse_drug_reactions\" column into embeddings\nadr_str_test = df_test[\"adverse_drug_reactions\"].tolist()\nadr_string_test = \",\".join(adr_str_test)\nadr_test_t = words_tensors(adr_string_test)\n\n# 3. Convert \"fp\" column into tensors\nfp_test_array = np.stack(df_test[\"fp\"])\nfp_test_array = fp_test_array.astype(\"int32\")\nfp_test_t = torch.from_numpy(fp_test_array)\nfp_test_t = torch.reshape(fp_test_t, (int(fp_test_array.size/2),2))\n\n# Concatenate adr tensors, drug class tensors and cyp strength tensors as X_test\nX_test = torch.cat([cyp_str_test_t, adr_test_t, fp_test_t], 0).float()\nX_test\n```\n\n::: {.cell-output .cell-output-display execution_count=160}\n```\ntensor([[0., 1.],\n        [0., 1.],\n        [0., 1.],\n        ...,\n        [0., 0.],\n        [0., 0.],\n        [0., 0.]], grad_fn=<CatBackward0>)\n```\n:::\n:::\n\n\nThis is followed by setting up y_train.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code code-fold=\"true\"}\n## y_train\n# Use drug_class column as target\n# Convert \"drug_class\" column into embeddings \n# total number of drug classes in df = 20 - len(set(df[\"drug_class\"])) - using embeddings instead of one-hot\ndc_str_train = df_train[\"drug_class\"].tolist()\ndc_string_train = \",\".join(dc_str_train)\ny_train = words_tensors(dc_string_train)\ny_train\n```\n\n::: {.cell-output .cell-output-display execution_count=161}\n```\ntensor([[-1.1321, -0.3473]], grad_fn=<EmbeddingBackward0>)\n```\n:::\n:::\n\n\nLastly, y_test is being specified.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code code-fold=\"true\"}\n## y_test\n# Convert \"drug_class\" column into embeddings \ndc_str_test = df_test[\"drug_class\"].tolist()\ndc_string_test = \",\".join(dc_str_test)\ny_test = words_tensors(dc_string_test)\ny_test\n```\n\n::: {.cell-output .cell-output-display execution_count=162}\n```\ntensor([[-0.4137, -0.1747]], grad_fn=<EmbeddingBackward0>)\n```\n:::\n:::\n\n\n<br>\n\n##### **Input preprocessing pipeline using PyTorch Dataset and DataLoader**\n\nThere is a size-mismatch-between-tensors warning when I'm trying to use PyTorch's TensorDataset(). I've found out that to use the data loader and tensor dataset, the first dimension of all tensors needs to be the same. Initially, they're not, where X_train.shape = [24313, 2], y_train.shape = [1, 2]. Eventually I've settled on two ways that can help with this: \n\n- use tensor.unsqueeze(dim = 1) or \n\n- use tensor[None] which'll insert a new dimension at the beginning, then it becomes: X_train.shape = [1, 24313, 2], y_train.shape = [1, 1, 2]\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nX_train[None].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=163}\n```\ntorch.Size([1, 19992, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nX_train.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=164}\n```\ntorch.Size([19992, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ny_train[None].shape\n```\n\n::: {.cell-output .cell-output-display execution_count=165}\n```\ntorch.Size([1, 1, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\ny_train.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=166}\n```\ntorch.Size([1, 2])\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Create a PyTorch dataset on training data set\ntrain_data = TensorDataset(X_train[None], y_train[None])\n# Sets a seed number to generate random numbers\ntorch.manual_seed(1)\nbatch_size = 1\n\n# Create a dataset loader\ntrain_dl = DataLoader(train_data, batch_size, shuffle = True)\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Create another PyTorch dataset on testing data set\ntest_data = TensorDataset(X_test[None], y_test[None])\ntorch.manual_seed(1)\nbatch_size = 1\ntest_dl = DataLoader(test_data, batch_size, shuffle=True)\n```\n:::\n\n\n<br>\n\n##### **Set up a simple DNN regression model** \n\nI'm only going to use a very simple two-layer DNN model to match the tiny dataset used here. There are many other types of neural network layers or bits and pieces that can be used to suit the goals and purposes of the dataset used. This [reference link](https://pytorch.org/docs/stable/nn.html) shows different types of neural network layers that can be used in PyTorch.\n\nBelow are some short notes regarding a neural network (NN) model:\n \n- goal of the model is to minimise loss function L(W) (where W = weight) to get the optimal model weights\n\n- matrix with W (for hidden layer) connects input to hidden layer; matrix with W (for outer layer) connects hidden to output layer\n\n- *Input layer* -> activation function of hidden layer -> *hidden layer* -> activation function of output layer -> *output layer* (a very-simplified flow diagram to show how the layers get connected to each other)\n\n\nAbout backpropagation for loss function:\n\n- backpropagation is a computationally efficient way to calculate partial derivatives of loss function to update weights in multi-layer NNs\n\n- it's based on calculus chain rule to compute derivatives of mathematical functions (automatic differentiation)\n\n- matrix-vector multiplications in backpropagation are computationally more efficient to calculate than matrix-matrix multiplications e.g. forward propagation\n\nNote: there are also [other types of activation functions available](https://pytorch.org/docs/stable/nn.functional.html#non-linear-activation-functions) to use in PyTorch.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code code-fold=\"true\"}\n# note: this is a very simple two-layer NN model only\n\n# Set up hidden units between two connected layers - one layer with 6 hidden units and the other with 3 hidden units\nhidden_units = [6, 3]\n# Input size same as number of columns in X_train\ninput_size = X_train.shape[1]\n# Initiate NN layers as a list\nall_layers = []\n\n## Specify how the input, hidden and output layers are going to be connected\n# For each hidden unit within the hidden units specified above:\nfor h_unit in hidden_units:\n    # specify sizes of input sample (input size = X_train col size) & output sample (hidden units) in each layer\n    # https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear\n    layer = nn.Linear(input_size, h_unit)\n    # add each layer\n    all_layers.append(layer)\n    # add activation function (trying rectified linear unit) for next layer\n    all_layers.append(nn.ReLU())\n    # for the next layer to be added, the input size will be the same size as the hidden unit\n    input_size = h_unit\n\n# Specify the last layer (where input_feature = hidden_units[-1] = 3)\nall_layers.append(nn.Linear(hidden_units[-1], 1))\n\n# Set up a container that'll connect all layers in the specified sequence in the model\nmodel = nn.Sequential(*all_layers)\nmodel\n```\n\n::: {.cell-output .cell-output-display execution_count=169}\n```\nSequential(\n  (0): Linear(in_features=2, out_features=6, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=6, out_features=3, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=3, out_features=1, bias=True)\n)\n```\n:::\n:::\n\n\n<br>\n\n##### **Train model**\n\nThis part is mainly about defining the loss function when training the model with the training data, and optimising model by using a stochastic gradient descent. One key thing I've gathered from trying to learn about deep learning is that we're aiming for global minima and not local minima (e.g. if learning rate is too small, this may end up with local minima; if learning rate is too large, it may end up over-estimating the global minima). I've also encountered the PyTorch padding method to make sure the input and target tensors are of the same size, otherwise the model will run into matrix broadcasting issue (which will likely influence the results). The training loss appears to have converged when the epoch runs reach 100 and/or after (note this may vary due to shuffle data sampling)... (I also think my data size is way too small to show a clear contrast in training loss convergence).\n\nReferences for: [nn.MSELoss()](https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss) - measures mean squared error between X and y, and [nn.functional.pad()](https://pytorch.org/docs/stable/generated/torch.nn.functional.pad.html#torch.nn.functional.pad) - pads tensor (increase tensor size) \n\nObtaining training loss via model training:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code code-fold=\"true\"}\n# Set up loss function\nloss_f = nn.MSELoss()\n# Set up stochastic gradient descent optimiser to optimise model (minimise loss) during training \n# lr = learning rate - default: 0.049787 (1*e^-3)\noptim = torch.optim.SGD(model.parameters(), lr=0.005)\n# Set training epochs (epoch: each cycle of training or passing through the training set)\nnum_epochs = 200\n# Set the log output to show training loss - for every 20 epochs\nlog_epochs = 20\ntorch.manual_seed(1)\n# Create empty lists to save training loss (for training and testing/validation sets)\ntrain_epoch_loss = []\ntest_epoch_loss = []\n\n#  Predict via training X_batch & obtain train loss via loss function from X_batch & y_batch\nfor epoch in range(num_epochs):\n    train_loss = 0\n    for X_batch, y_batch in train_dl:\n        # Make predictions\n        predict = model(X_batch)[:, 0]\n        # Make input tensors the same size as y_batch tensors\n        predict_pad = F.pad(predict[None], pad=(1, 0, 0, 0))\n        # Calculate training loss\n        loss = loss_f(predict_pad, y_batch)\n        # Calculate gradients (backpropagations)\n        loss.backward(retain_graph=True)\n        # Update parameters using gradients\n        optim.step()\n        # Reset gradients back to zero\n        optim.zero_grad()\n        train_loss += loss.item()\n    \n    if epoch % log_epochs == 0:\n        print(f\"Epoch {epoch} Loss {train_loss/len(train_dl):.4f}\")\n\n    train_epoch_loss.append(train_loss)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 0 Loss 0.8081\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 20 Loss 0.7587\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 40 Loss 0.7225\nEpoch 60 Loss 0.6962\nEpoch 80 Loss 0.6776\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 100 Loss 0.6648\nEpoch 120 Loss 0.6562\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 140 Loss 0.6505\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 160 Loss 0.6469\nEpoch 180 Loss 0.6446\n```\n:::\n:::\n\n\nObtaining test or validation loss:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code code-fold=\"true\"}\n# Predict via testing X_batch & obtain test loss \nfor epoch in range(num_epochs):\n    test_loss = 0\n    for X_batch, y_batch in test_dl:\n        # Make predictions\n        predict_test = model(X_batch)[:, 0]\n        # Make input tensors the same size as y_batch tensors\n        predict_pad_test = F.pad(predict_test[None], pad=(1, 0, 0, 0))\n        # Calculate training loss\n        loss = loss_f(predict_pad_test, y_batch)\n        # Calculate gradients (backpropagations)\n        loss.backward(retain_graph=True)\n        # Update parameters using gradients\n        optim.step()\n        # Reset gradients back to zero\n        optim.zero_grad()\n        test_loss += loss.item()\n    \n    if epoch % log_epochs == 0:\n        print(f\"Epoch {epoch} Loss {test_loss/len(test_dl):.4f}\")\n\n    test_epoch_loss.append(test_loss)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 0 Loss 0.1030\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 20 Loss 0.0963\nEpoch 40 Loss 0.0921\nEpoch 60 Loss 0.0895\nEpoch 80 Loss 0.0880\nEpoch 100 Loss 0.0870\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 120 Loss 0.0865\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEpoch 140 Loss 0.0861\nEpoch 160 Loss 0.0859\nEpoch 180 Loss 0.0858\n```\n:::\n:::\n\n\n<br>\n\n##### **Evaluate model**\n\nShowing train and test losses over training epochs in a plot:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code code-fold=\"true\"}\nplt.plot(train_epoch_loss, label=\"train_loss\")\nplt.plot(test_epoch_loss, label=\"test_loss\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Loss\")\nplt.legend()\nplt.show\n```\n\n::: {.cell-output .cell-output-display execution_count=172}\n```\n<function matplotlib.pyplot.show(close=None, block=None)>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](2_ADR_regressor_files/figure-html/cell-33-output-2.png){width=589 height=429}\n:::\n:::\n\n\nAt the moment, when this notebook is re-run on a refreshed kernel, this leads to a different train and test split each time, and also leading to a different train and test (validation) loss each time. There may be two types of scenarios shown in the plot above where:\n\n- test loss is higher than train loss (overfitting) - showing the model may be way too simplified and is likely under-trained\n- train loss is higher than test loss (underfitting) - showing that the model may not have been trained well, and is unable to learn the features in the training data and apply them to the test data\n\nWhen there are actually more training data available with also other hyperparameters fine tuned, it may be possible to see another scenario where both test loss and train loss are very similar in trend, meaning the model is being trained well and able to generalise the training to the unseen data. \n\nTo mitigate overfitting: \n\n- firstly there should be more training data than what I've had here\n\n- use L1 or L2 regularisation to minimise model complexity by adding penalities to large weights\n\n- use early stopping during model training to stop training the model when test loss is becoming higher than the train loss\n\n- use [torch.nn.Dropout()](https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html) to randomly drop out some of the neurons to ensure the exisiting neurons will learn features without being too reliant on other neighbouring neurons in the network\n\n- *I'll try the early stopping or drop out method in future posts since current post is relatively long already...* (***[note](https://jhylin.github.io/Data_in_life_blog/posts/22_Simple_dnn_adrs/4_Prevent_overfit_note.html) on preventing model overfitting in DNN added in February 2025***)\n\nTo overcome underfitting:\n\n- increase training epochs\n- minimise regularisation\n- consider building a more complex or deeper neural network model\n\nI'm trying to keep this post simple so have only used mean squared error (MSE) and mean absolute error (MAE) to evaluate the model which has made a prediction on the test set. The smaller the MSE, the less error the model has when making predictions. However this is not the only metric that will determine if a model is optimal for predictions, as I've also noticed that every time there's a different train and test split, the MAE and MSE values will vary too, so it appears that some splits will generate smaller MSE and other splits will lead to larger MSE.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code code-fold=\"true\"}\n# torch.no_grad() - disable gradient calculations to reduce memory usage for inference (also like a decorator)\nwith torch.no_grad():\n    predict_test = model(X_test.float())[:, 0]\n    # Padding target tensor with set size of [(1, 2)] as input tensor size will vary \n    # when notebook is re-run each time due to butina split with sample shuffling\n    # so need to pad the target tensor accordingly\n    y_test_pad = F.pad(y_test, pad=(predict_test[None].shape[1] - y_test.shape[1], 0, 0, 0))\n    loss_new = loss_f(predict_test[None], y_test_pad)\n    print(f\"MSE for test set: {loss_new.item():.4f}\")\n    print(f\"MAE for test set: {nn.L1Loss()(predict_test[None], y_test_pad).item():.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMSE for test set: 0.0737\nMAE for test set: 0.2680\n```\n:::\n:::\n\n\n<br>\n\n##### **Save model**\n\nOne way to save the model is like below.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\npath = \"adr_regressor.pt\"\ntorch.save(model, path)\nmodel_reload = torch.load(path)\nmodel_reload.eval()\n```\n\n::: {.cell-output .cell-output-display execution_count=174}\n```\nSequential(\n  (0): Linear(in_features=2, out_features=6, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=6, out_features=3, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=3, out_features=1, bias=True)\n)\n```\n:::\n:::\n\n\n<br>\n\n##### **Reload model**\n\nThe saved model is reloaded below with a check to make sure the reloaded version is the same as the saved version.\n\nReferences for: [torch.max](https://pytorch.org/docs/stable/generated/torch.max.html#torch.max) and [torch.argmax](https://pytorch.org/docs/stable/generated/torch.argmax.html#torch-argmax)\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\npred_reload = model_reload(X_test)\ny_test_rel_pad = F.pad(y_test, pad=(pred_reload[None].shape[1] - y_test.shape[1], 0, 0, 0))\ncorrect = (torch.argmax(pred_reload, dim=1) == y_test_rel_pad).float()\naccuracy = correct.mean()\nprint(f\"Test accuracy: {accuracy:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest accuracy: 0.9998\n```\n:::\n:::\n\n\n<br>\n\nA few things to consider in the end:\n\n- I haven't done feature standardisation for X_train which is to centre X_train mean and divide by its standard deviation, code may be like this, X_train_normalised = (X_train - np.mean(X_train))/np.std(X_train) (if used on training data, need to apply this to testing data too)\n\n- Training features are certainly too small, however, the main goal of this very first post is to get an overall idea of how to construct a baseline DNN regression model. There are lots of other things that can be done to the ADRs data e.g. adding more drug molecular features and properties. I have essentially only used the initial molecular fingerprints generated when doing the data split to add a bit of molecular aspect in the training dataset.\n\n- I haven't taken into account the frequencies of words (e.g. same drug classes and same ADR terms across different drugs) in the training and testing data, however, the aim of this first piece of work is also not a semantic analysis in natural language processing so this might not be needed...\n\n- There may be other PyTorch functions that I do not yet know about that will deal with small datasets e.g. perhaps [torch.sparse](https://pytorch.org/docs/stable/sparse.html) may be useful?... so this piece is certainly not the only way to do it, but one of the many ways to work with small data\n\n<br>\n\n##### **Acknowledgements**\n\nI'm very thankful for the existence of these references, websites and reviewer below which have helped me understand (or scratch a small surface of) deep learning and also solve the coding issues mentioned in this post:\n\n- [PyTorch forums](https://discuss.pytorch.org/)\n\n- [Stack Overflow](https://stackoverflow.com/)\n\n- Raschka, Sebastian, Yuxi (Hayden) Liu, and Vahid Mirjalili. 2022. Machine Learning with PyTorch and Scikit-Learn. Birmingham, UK: Packt Publishing. \n\n- [Noel O'Boyle](https://baoilleach.blogspot.com) for feedback on this post\n\n",
    "supporting": [
      "2_ADR_regressor_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}